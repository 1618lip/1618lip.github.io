### _CSE 120 @ UCSD_ 

<details>
<summary><b>OS Basics</b></summary>
	<br>
	<ul>
		<li>
	<details>
	<summary><b>Lecture 2: Interactions with Apps and Hardware</b></summary> 

	
## What is an OS?

- Code that sits between applications and hardware
- Provides abstractions to layers above
- Implements abstractions for and manages resources below

---

## Hardware of a Typical Computer
- System bus, CPUs, Memory, Network, Storage

---

## Software of a Typical (Unix) System

**User Level:**
- Application (user code, library calls)
- Libraries (compiled, header-defined interfaces)

**Kernel Level:**
- Portable OS Layer
- Machine-dependent Layer
- Bootstrap, System initialization
- Interrupts, Exceptions
- I/O device drivers, Memory management
- Processor & mode management

> Note: “kernel” ≈ “OS”

---

## Questions for this lecture

- How do we separate the OS layer from apps (and libraries)?
- How do we cross between these layers?
- With support from the hardware!

---

## Protection Mechanisms

- **Privileged instructions**
- **Memory protection**

## OS Interactions

- **Faults**
- **System calls**
- **Interrupts**

---

## Dual-Mode Operation

- Kernel mode: Can run all instructions
- User mode: Restricted, non-privileged instructions
- Mode indicated by a mode bit in a protected CPU control register

---

## Privileged Instructions

- Only executable in kernel mode
- CPU checks mode bit before executing
- Privileged actions include:
  - Direct I/O access
  - Memory management state changes
  - Protected register manipulation

---

## Example of a Privileged Instruction

- `HLT`: halts the CPU (only works in kernel mode)

---

## Memory Protection

- OS must:
  - Protect itself from user programs
  - Protect programs from each other
- Memory-management hardware enables protection:
  - Page tables, segmentation, TLB
  - Requires privileged instructions to configure

---

## Events

- **Definition**: An unnatural change in control flow
  - Stops current execution
  - May change context/mode
- OS defines handlers for each event type
- Kernel mode execution only triggered by an event

---

## Types of Events

- **Interrupts**: From external events (e.g., I/O, timers)
- **Exceptions** (Traps):
  - Caused by instruction execution
  - Include faults (e.g., privileged instruction) and system calls

---

## Faults

- Examples: divide by zero, page fault
- CPU:
  - Saves state
  - Switches to kernel mode
  - Finds & executes the appropriate fault handler
- Handler reverses these steps to return control

---

## Handling Faults

### Recovery
- OS may "fix" the issue (e.g., page fault)
- User program resumes after correction

### Termination
- If unrecoverable:
  - Kill process (no handler)
  - Write core dump, terminate

- **Kernel faults** = system crash:
  - Unix panic, Windows BSOD

---

## System Calls

- Interface between user programs and OS
- Performed using special instructions

### Categories:
- Process, memory, file, device management
- Communication

---

## System Call Mechanism

- System call instruction causes an exception
  - Transfers control to kernel
  - Passes syscall number
  - Saves/restores state
- Requires hardware support for context switch

---

## Examples of System Call Instructions

- `INT`: triggers syscall
- `SYSCALL`: on newer 64-bit CPUs

---

## System Call Example

```plaintext
User level:       read()
                    ↓
Library:          INT $0x03
                    ↓
Kernel:           read() routine
                    ↓
Return to user level
```

- Syscall numbers assigned by OS

---

## Referencing Data Between Spaces

- OS and user code have different address spaces
- Use **names/handles**, not raw pointers (e.g., file descriptors)

---

## Interrupts

- Triggered by hardware (timers, I/O)
- **Precise** on modern CPUs (instruction boundaries)

### Handling:
- Disable lower-priority interrupts
- Save state
- Execute ISR (Interrupt Service Routine)
- Re-enable interrupts
- Resume execution

---

## Example: Timer Interrupt

- Timer generates interrupt periodically
- Privileged instruction sets timer
- Used to:
  - Reclaim CPU (scheduling)
  - Enforce time limits
  - Sleep/delays

---

## Example: I/O Interrupt

- OS starts I/O → Device completes → Sends interrupt
- CPU context switches to ISR
- Resumes original process

---

## x86 Interrupts and Exceptions (1)

| Vector # | Mnemonic | Description | Type        |
|----------|----------|-------------|-------------|
| 0        | #DE      | Divide error | Fault       |
| 1        | #DB      | Debug        | Fault/Trap  |
| 2        | -        | NMI          | Interrupt   |
| 3        | #BP      | Breakpoint   | Trap        |
| 4        | #OF      | Overflow     | Trap        |
| 5        | #BR      | BOUND        | Trap        |
| 6        | #UD      | Invalid opcode | Fault     |
| 7        | #NM      | Device not available | Fault |
| 8        | #DF      | Double fault | Abort       |
| 9        | -        | Segment overrun | Fault    |

---

## x86 Interrupts and Exceptions (2)

| Vector # | Mnemonic | Description | Type        |
|----------|----------|-------------|-------------|
| 10       | #TS      | Invalid TSS | Fault       |
| 11       | #NP      | Segment not present | Fault |
| 12       | #SS      | Stack fault | Fault       |
| 13       | #GP      | General protection | Fault |
| 14       | #PF      | Page fault  | Fault       |
| 15       | -        | Reserved    | Fault       |
| 16       | #MF      | FP error    | Fault       |
| 17       | #AC      | Alignment check | Fault   |
| 18       | #MC      | Machine check | Abort     |
| 19–31    | -        | Reserved    | -           |
| 32–255   | -        | User-defined| Interrupt   |

---

## The OS as a Giant Interrupt Handler

- All kernel entry via:
  - Timer/I/O interrupts
  - Faults
  - System calls

```plaintext
[User Level] → [Event] → [Kernel Level]
→ Dispatcher → Fault Handler / ISR / Syscall Handler
```

---

## Practice Question

- After the call to `main()`, how many mode switches does the program perform?

---

## Summary

### Protection:
- Privileged instructions
- Memory protection

### OS Interactions:
- Faults
- System calls
- Interrupts
---
</details>
</li>
<li>
<details>
	<summary><b>Lecture 3: Processes</b></summary>
	<h3>Review Question: Events</h3>
  <ul>
    <li><strong>Similarities:</strong>
      <ul>
        <li>Trap to the OS</li>
        <li>Run in kernel mode</li>
        <li>Hardware saves state (PC, registers)</li>
      </ul>
    </li>
    <li><strong>Differences:</strong>
      <ul>
        <li>Interrupts: asynchronous (external)</li>
        <li>Exceptions: synchronous (caused by instructions)</li>
      </ul>
    </li>
  </ul>

  <h3>Next Several Lectures</h3>
  <ul>
    <li>Processes (today)</li>
    <li>Threads (next lecture)</li>
    <li>Synchronization</li>
  </ul>

  <h3>Today’s Outline</h3>
  <ul>
    <li>What is a process?</li>
    <li>How to represent a running program?</li>
    <li>APIs to interact with processes</li>
  </ul>

  <h3>The Process</h3>
  <p>An OS abstraction for a running program used for execution, scheduling, and resource management.</p>

  <h3>Process Components</h3>
  <ul>
    <li>Address space</li>
    <li>Code and data</li>
    <li>Execution stack</li>
    <li>Program counter (PC)</li>
    <li>Registers</li>
    <li>OS resources (files, sockets)</li>
    <li>Identified by PID</li>
  </ul>

  <h3>Process vs. Program</h3>
  <p><strong>Program</strong>: static code<br>
     <strong>Process</strong>: program in execution with memory, registers, etc.</p>

  <h3>Basic Process Address Space</h3>
  <pre>
0xFFFFFFFF
   Stack ↑
   Heap
   Static Data
   Code
0x00000000
  </pre>

  <h3>Process State</h3>
  <ul>
    <li>Running: currently using CPU</li>
    <li>Ready: waiting to be scheduled</li>
    <li>Waiting: blocked, waiting for I/O</li>
  </ul>

  <h3>The Processing Illusion</h3>
  <ul>
    <li>Each process thinks it owns the CPU</li>
    <li>Managed by:
      <ul>
        <li>Timer interrupts</li>
        <li>Context saving</li>
        <li>Schedulers</li>
      </ul>
    </li>
  </ul>

  <h3>Process Control Block (PCB)</h3>
  <p>Contains all process info: memory, execution state, scheduling, I/O</p>

  <h3>Process Creation</h3>
  <ul>
    <li>Each process has a parent</li>
    <li>Linux root process: <code>init</code> or <code>systemd</code></li>
    <li>Parent can wait or run concurrently with child</li>
  </ul>

  <h3>Process Creation APIs</h3>
  <h4>Windows: <code>CreateProcess()</code></h4>
  <pre>BOOL CreateProcess(char *prog, char *args);</pre>

  <h4>Unix: <code>fork()</code></h4>
  <pre>int fork();</pre>
  <p>Returns 0 to child, child PID to parent</p>

  <h3>fork() Example</h3>
  <pre>
int main() {
  int child_pid = fork();
  if (child_pid == 0) {
    printf("I am the child, PID: %d\n", getpid());
  } else {
    printf("My child's PID: %d\n", child_pid);
  }
}
  </pre>

  <h3>exec()</h3>
  <pre>int exec(char *prog, char *argv[]);</pre>
  <ul>
    <li>Replaces process memory with new program</li>
    <li>Files remain open</li>
    <li>Returns only on error</li>
  </ul>

  <h3>Process Termination</h3>
  <ul>
    <li><code>exit(int status)</code> (Unix)</li>
    <li><code>ExitProcess(int status)</code> (Windows)</li>
    <li>OS reclaims memory, closes files, removes PCB</li>
  </ul>

  <h3>wait()</h3>
  <p>Parent pauses until child exits</p>
  <ul>
    <li><code>wait()</code>: any child</li>
    <li><code>waitpid()</code>: specific child</li>
    <li>Required to avoid zombie processes</li>
  </ul>

  <h3>Unix Shell Example</h3>
  <pre>
while (1) {
  char *cmd = read_command();
  int pid = fork();
  if (pid == 0) {
    exec(cmd);
  } else {
    waitpid(pid);
  }
}
  </pre>

  <h3>Poll Questions</h3>
  <p><strong>Which does the OS provide?</strong><br>
     ✅ D: Physical memory allocation</p>

  <p><strong>Privileged Instruction?</strong><br>
     ✅ C: INVD (invalidate caches)</p>


</details>
</li>	
<li>
	<details>
		<summary><b>Lecture 4: Threads</b></summary>
		To be filled
	</details>
</li>
</ul>
</details>
