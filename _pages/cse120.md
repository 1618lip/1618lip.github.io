# Operating Systems 
### _CSE 120 @ UCSD_ 

<details>
<summary><b>OS Basics</b></summary>
	<br>
	<ul>
		<li>
	<details>
	<summary><b>Lecture 2: Interactions with Apps and Hardware</b></summary> 
<pre>
	
## What is an OS?

- Code that sits between applications and hardware
- Provides abstractions to layers above
- Implements abstractions for and manages resources below

---

## Hardware of a Typical Computer
- System bus, CPUs, Memory, Network, Storage

---

## Software of a Typical (Unix) System

**User Level:**
- Application (user code, library calls)
- Libraries (compiled, header-defined interfaces)

**Kernel Level:**
- Portable OS Layer
- Machine-dependent Layer
- Bootstrap, System initialization
- Interrupts, Exceptions
- I/O device drivers, Memory management
- Processor & mode management

> Note: “kernel” ≈ “OS”

---

## Questions for this lecture

- How do we separate the OS layer from apps (and libraries)?
- How do we cross between these layers?
- With support from the hardware!

---

## Protection Mechanisms

- **Privileged instructions**
- **Memory protection**

## OS Interactions

- **Faults**
- **System calls**
- **Interrupts**

---

## Dual-Mode Operation

- Kernel mode: Can run all instructions
- User mode: Restricted, non-privileged instructions
- Mode indicated by a mode bit in a protected CPU control register

---

## Privileged Instructions

- Only executable in kernel mode
- CPU checks mode bit before executing
- Privileged actions include:
  - Direct I/O access
  - Memory management state changes
  - Protected register manipulation

---

## Example of a Privileged Instruction

- `HLT`: halts the CPU (only works in kernel mode)

---

## Memory Protection

- OS must:
  - Protect itself from user programs
  - Protect programs from each other
- Memory-management hardware enables protection:
  - Page tables, segmentation, TLB
  - Requires privileged instructions to configure

---

## Events

- **Definition**: An unnatural change in control flow
  - Stops current execution
  - May change context/mode
- OS defines handlers for each event type
- Kernel mode execution only triggered by an event

---

## Types of Events

- **Interrupts**: From external events (e.g., I/O, timers)
- **Exceptions** (Traps):
  - Caused by instruction execution
  - Include faults (e.g., privileged instruction) and system calls

---

## Faults

- Examples: divide by zero, page fault
- CPU:
  - Saves state
  - Switches to kernel mode
  - Finds & executes the appropriate fault handler
- Handler reverses these steps to return control

---

## Handling Faults

### Recovery
- OS may "fix" the issue (e.g., page fault)
- User program resumes after correction

### Termination
- If unrecoverable:
  - Kill process (no handler)
  - Write core dump, terminate

- **Kernel faults** = system crash:
  - Unix panic, Windows BSOD

---

## System Calls

- Interface between user programs and OS
- Performed using special instructions

### Categories:
- Process, memory, file, device management
- Communication

---

## System Call Mechanism

- System call instruction causes an exception
  - Transfers control to kernel
  - Passes syscall number
  - Saves/restores state
- Requires hardware support for context switch

---

## Examples of System Call Instructions

- `INT`: triggers syscall
- `SYSCALL`: on newer 64-bit CPUs

---

## System Call Example

```plaintext
User level:       read()
                    ↓
Library:          INT $0x03
                    ↓
Kernel:           read() routine
                    ↓
Return to user level
```

- Syscall numbers assigned by OS

---

## Referencing Data Between Spaces

- OS and user code have different address spaces
- Use **names/handles**, not raw pointers (e.g., file descriptors)

---

## Interrupts

- Triggered by hardware (timers, I/O)
- **Precise** on modern CPUs (instruction boundaries)

### Handling:
- Disable lower-priority interrupts
- Save state
- Execute ISR (Interrupt Service Routine)
- Re-enable interrupts
- Resume execution

---

## Example: Timer Interrupt

- Timer generates interrupt periodically
- Privileged instruction sets timer
- Used to:
  - Reclaim CPU (scheduling)
  - Enforce time limits
  - Sleep/delays

---

## Example: I/O Interrupt

- OS starts I/O → Device completes → Sends interrupt
- CPU context switches to ISR
- Resumes original process

---

## x86 Interrupts and Exceptions (1)

| Vector # | Mnemonic | Description | Type        |
|----------|----------|-------------|-------------|
| 0        | #DE      | Divide error | Fault       |
| 1        | #DB      | Debug        | Fault/Trap  |
| 2        | -        | NMI          | Interrupt   |
| 3        | #BP      | Breakpoint   | Trap        |
| 4        | #OF      | Overflow     | Trap        |
| 5        | #BR      | BOUND        | Trap        |
| 6        | #UD      | Invalid opcode | Fault     |
| 7        | #NM      | Device not available | Fault |
| 8        | #DF      | Double fault | Abort       |
| 9        | -        | Segment overrun | Fault    |

---

## x86 Interrupts and Exceptions (2)

| Vector # | Mnemonic | Description | Type        |
|----------|----------|-------------|-------------|
| 10       | #TS      | Invalid TSS | Fault       |
| 11       | #NP      | Segment not present | Fault |
| 12       | #SS      | Stack fault | Fault       |
| 13       | #GP      | General protection | Fault |
| 14       | #PF      | Page fault  | Fault       |
| 15       | -        | Reserved    | Fault       |
| 16       | #MF      | FP error    | Fault       |
| 17       | #AC      | Alignment check | Fault   |
| 18       | #MC      | Machine check | Abort     |
| 19–31    | -        | Reserved    | -           |
| 32–255   | -        | User-defined| Interrupt   |

---

## The OS as a Giant Interrupt Handler

- All kernel entry via:
  - Timer/I/O interrupts
  - Faults
  - System calls

```plaintext
[User Level] → [Event] → [Kernel Level]
→ Dispatcher → Fault Handler / ISR / Syscall Handler
```

---

## Practice Question

- After the call to `main()`, how many mode switches does the program perform?

---

## Summary

### Protection:
- Privileged instructions
- Memory protection

### OS Interactions:
- Faults
- System calls
- Interrupts
---
</pre>	
</details>
</li>
<li>
<details>
	<summary><b>Lecture 3: Processes</b></summary>

## Review Question: Events

**Similarities between interrupts and exceptions:**
- Both trap to the OS
- Handler runs in **kernel mode**
- Hardware saves state (PC, registers)

**Differences:**
- **Interrupts**: external (asynchronous)
- **Exceptions**: caused by executing instructions (synchronous)

---

## Next Several Lectures

Topics:
- **Processes** (today)
- **Threads** (next lecture)
- **Synchronization**

---

## Today’s Outline

- What is a process?
- How do we represent a running program?
- APIs for interacting with processes

---

## The Process

- **Abstraction for a running program**
- Simplest: sequential, 1 instruction at a time
- Used for execution, scheduling, and resource management

---

## Process Components

A process contains:
- Address space
- Code & data
- Execution stack
- Program counter (PC)
- CPU registers
- OS resources (open files, network sockets, etc.)
- Identified by **PID**

---

## Unix PIDs

- Check with: `top` or `ps`

---

## Process vs. Program

- **Program**: static code
- **Process**: instance of a program in execution
  - Includes memory, registers, PC, open files

---

## Basic Process Address Space

```
0xFFFFFFFF
  Stack
  ↑
  Heap
  Static Data (Data Segment)
  Code (Text Segment)
0x00000000
```
- Includes stack pointer (SP) and PC

---

## Process State

- **Running**: executing on CPU
- **Ready**: ready to run, waiting for CPU
- **Waiting (Blocked)**: waiting on event (I/O, etc.)

Processes move between states.

---

## The Processing Illusion

- Each process thinks it owns the CPU
- **Reality**:
  - 1 CPU: time-sharing
  - Many CPUs: sharing across cores
- Managed with:
  - Timer interrupts
  - Context saving
  - Schedulers

---

## Process Data Structure

- Kernel uses **Process Control Block (PCB)**:
  - Execution state
  - Memory info
  - Scheduling info
  - I/O and file data

> PCB in Linux (`task_struct`) = ~833 LOC in Linux 6.12.19

---

## Questions About Processes

- How many can be in the running state?
- What state is most common?
- How many processes can a system handle?
- Is the OS itself a process?

---

## Process Creation

- Each process is created by another (parent → child)
- First process (Linux): `init` or `systemd` (PID 1)
- Child can inherit resources and run in parallel or sequentially with parent

---

## Process Tree

- Visualized with `pstree`
- Parent → child structure (e.g., SSH sessions)

---

## Process Creation API

**Options:**
- Create from scratch
- Clone existing process

---

## Windows: `CreateProcess`

```c
BOOL CreateProcess(char *prog, char *args);
```

- Allocates new PCB, address space
- Loads program
- Copies args into memory
- Initializes context and state

---

## Unix: `fork()`

```c
int fork();
```

- Clones:
  - PCB
  - Address space (copy-on-write)
  - File descriptors
  - Hardware context

- Returns:
  - 0 to child
  - PID of child to parent

---

## fork() Example

```c
int main() {
  int child_pid = fork();
  if (child_pid == 0) {
    printf("I am the child, PID: %d\n", getpid());
  } else {
    printf("My child's PID: %d\n", child_pid);
  }
}
```

**Possible output:**
```
My child's PID: 35220
I am the child, PID: 35220
```
or vice versa

---

## Duplicating and Diverging Address Spaces

```c
child_pid = fork();
if (child_pid == 0)
  printf("child");
else
  printf("parent");
```

- **Separate execution paths** after `fork()`

---

## Why fork()?

- Useful when:
  - Child cooperates with parent
  - Child uses parent’s data

**Example:** Web server

```c
while (1) {
  int sock = accept();
  int pid = fork();
  if (pid == 0)
    handle_request();
}
```

---

## Unix: `exec()`

```c
int exec(char *prog, char *argv[]);
```

- Stops current process
- Loads new program into address space
- Keeps file descriptors open
- Initializes context
- **Does not create a new process**

Returns only on **error**

---

## exec() Example

```c
main() {
  exec("b.out");
}
```

- Replaces code/data/stack
- Keeps file descriptors (e.g., STDIN/OUT)

---

## Process Termination

- Use: `exit(int)` (Unix), `ExitProcess(int)` (Windows)
- OS:
  - Frees memory/resources
  - Closes files
  - Deletes PCB

> OS does cleanup — not user program!

---

## `wait()` a Second…

- Used to pause parent until child exits

```c
wait();     // waits for any child
waitpid();  // waits for specific child
```

- Required to avoid **zombies**
- If parent exits first → child is adopted by `init`

---

## Unix Shell Example

```c
while (1) {
  char *cmd = read_command();
  int pid = fork();
  if (pid == 0) {
    // Set up redirection, etc.
    exec(cmd);
    panic("exec failed");
  } else {
    waitpid(pid);
  }
}
```

---

## Questions to Think About

- What happens if you run `exec bash` in a shell?
- What happens if you run `exec ls` in a shell?

---

## Poll: OS Components

Which of the following does the OS provide?

- A. CPU cores ✗
- B. gdb/editor/compiler ✗
- C. Web browser ✗
- D. Physical memory allocation ✅
- E. System call instruction docs ✗

---

## Poll: Privileged Instructions

Which is privileged?

- A: ADD ✗
- B: CPUID ✗
- C: **INVD** ✅
- D: INT ✗
- E: RET ✗

---
</details>
</li>	
<li>
	<details>
		<summary><b>Lecture 4: Threads</b></summary>
		
	</details>
</li>
</ul>
</details>
